// Defined by user
enum UserEnum {
    A,
    B,
    C,
}

// Defined by user
impl TryFrom<u8> for UserEnum {
    type Error = String;
    fn try_from(value: u8) -> Result<UserEnum, String> {
        match value {
            0 => Ok(UserEnum::A),
            1 => Ok(UserEnum::B),
            2 => Ok(UserEnum::C),
            _ => Err("Invalid value".to_string()),
        }
    }
}

// Defined by user
// #[header]
struct UserPacketA {
    // #[bind(UserEnum)]
    a: u8,
    b: u64,
    c: [u8; 1024],
}

// Generated by macro
#[repr(C)]
#[derive(Debug)]
struct UserPacketAReferred<'a> {
    magic: &'a [u8; 4],
    a: &'a u8,
    b: &'a u64,
    c: &'a [u8; 1024],
    crc: &'a u32,
    next: &'a [u8; 4],
}

// Defined by user
// #[header]
struct UserPacketB {
    // #[bind(UserEnum)]
    a: u8,
    b: u64,
    c: [u8; 1024],
}

// Generated by macro
#[repr(C)]
#[derive(Debug)]
struct UserPacketBReferred<'a> {
    magic: &'a [u8; 4],
    a: &'a u8,
    b: &'a u64,
    c: &'a [u8; 1024],
    crc: &'a u32,
    next: &'a [u8; 4],
}

// Generated by macro
enum Packet {
    UserPacketA(UserPacketA),
    UserPacketB(UserPacketB),
}

// Generated by macro
enum PacketRefered<'a> {
    UserPacketA(UserPacketAReferred<'a>),
    UserPacketB(UserPacketBReferred<'a>),
}

// Defined by user
struct PayloadA {
    a: String,
    b: bool,
}

// Defined by user
struct PayloadB {
    a: Vec<String>,
}

// Generated by macro
enum Payload {
    PayloadA(PayloadA),
    PayloadB(PayloadB),
}

// Generated by macro
#[repr(C)]
#[derive(Debug)]
struct HeaderRef<'a> {
    sig: &'a [u8; 4],
    length: &'a u32,
    crc: &'a u32,
    next: &'a [u8; 4],
}

// Generated by macro
#[repr(C)]
#[derive(Debug)]
struct Header {
    sig: [u8; 4],
    length: u32,
    crc: u32,
    next: [u8; 4],
}

// Generated by macro
struct Entity {
    header: Header,
    packet: Vec<Packet>,
    payload: Payload,
}

// Generated by macro
struct EntityReferred<'a> {
    header: HeaderRef<'a>,
    packet: Vec<PacketRefered<'a>>,
    payload: &'a [u8],
}

trait Reading {
    fn read(data: &[u8]) -> Result<Option<EntityReferred<'_>>, String>;
}

fn parse<'a, T, K>(data: &'a [u8]) -> Result<&'a T, String> {
    use std::mem;

    if data.len() < mem::size_of::<K>() {
        return Err(format!(
            "Not enought data; data size = {}b; required = {}b",
            data.len(),
            mem::size_of::<K>()
        ));
    }

    Ok(unsafe { &*(data.as_ptr() as *const T) })
}

fn parse_header(data: &[u8]) -> Result<HeaderRef, String> {
    use std::mem;

    if data.len() < mem::size_of::<Header>() {
        return Err(format!(
            "Not enought data; data size = {}b; required = {}b",
            data.len(),
            mem::size_of::<Header>()
        ));
    }

    if data.as_ptr() as usize % std::mem::align_of::<Header>() != 0 {
        return Err(format!(
            "Invalid align: {} to {} gives {}",
            data.as_ptr() as usize,
            std::mem::align_of::<Header>(),
            data.as_ptr() as usize % std::mem::align_of::<Header>()
        ));
    }

    let sig = unsafe { &*(data.as_ptr() as *const [u8; 4]) };
    let length = unsafe { &*(data.as_ptr().add(4) as *const u32) };
    let crc = unsafe { &*(data.as_ptr().add(8) as *const u32) };
    let next = unsafe { &*(data.as_ptr().add(12) as *const [u8; 4]) };

    Ok(HeaderRef {
        sig,
        length,
        crc,
        next,
    })
}

#[test]
fn test() {
    let raw_data = Box::new([
        b'L', b'O', b'G', b'F', // Magic number
        0x10, 0x00, 0x00, 0x00, // Length (16)
        0x12, 0x34, 0x56, 0x78, // CRC
        b'N', b'E', b'X', b'T', // Next header magic
    ]);
    // let header_ref = parse::<HeaderRef, Header>(raw_data).expect("Failed to parse header");
    let header_ref = parse_header(&*raw_data).expect("Failed to parse header");

    println!("Parsed header: {:?}", header_ref);
}